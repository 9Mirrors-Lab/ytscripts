import { YouTubeTranscript } from 'youtube-transcript';nninterface TranscriptEntry {n  offset: number;n  duration: number;n  text: string;n}nninterface VideoMetadata {n  title: string;n  channelName: string;n  thumbnailUrl: string;n}nnexport const extractVideoId = (url: string): string => {n  const patterns = [n    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,n    /youtube\.com\/watch\?.*v=([^&\n?#]+)/n  ];nn  for (const pattern of patterns) {n    const match = url.match(pattern);n    if (match) {n      return match[1];n    }n  }nn  // If no pattern matches, assume it's already a video IDn  return url;n};nnexport const getYouTubeMetadata = async (url: string): Promise<VideoMetadata | null> => {n  try {n    const response = await fetch(`https://www.youtube.com/oembed?url=${encodeURIComponent(url)}&format=json`);n    if (!response.ok) {n      throw new Error('Failed to fetch metadata');n    }n    n    const data = await response.json();n    const videoId = extractVideoId(url);n    n    return {n      title: data.title || 'Unknown Video',n      channelName: data.author_name || 'Unknown Channel',n      thumbnailUrl: `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`n    };n  } catch (error) {n    console.error('Error fetching YouTube metadata:', error);n    return null;n  }n};nnexport const getTranscript = async (videoId: string): Promise<TranscriptEntry[]> => {n  try {n    const transcript = await YouTubeTranscript.fetchTranscript(videoId);n    return transcript.map(entry => ({n      offset: entry.offset,n      duration: entry.duration,n      text: entry.textn    }));n  } catch (error) {n    console.error('Error fetching transcript:', error);n    throw new Error('Failed to fetch transcript');n  }n};nnexport const formatTimestamp = (seconds: number): string => {n  const hours = Math.floor(seconds / 3600);n  const minutes = Math.floor((seconds % 3600) / 60);n  const secs = Math.floor(seconds % 60);nn  if (hours > 0) {n    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;n  } else {n    return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;n  }n};nnexport const createMarkdownTranscript = (transcript: TranscriptEntry[], videoId: string, metadata?: VideoMetadata): string => {n  const lines = [n    `# ${metadata?.title || 'YouTube Transcript'} - ${videoId}\n`,n    `*Generated from video: https://youtu.be/${videoId}*\n`,n    metadata?.channelName ? `*Channel: ${metadata.channelName}*\n` : '',n    '---\n\n'n  ];nn  transcript.forEach(entry => {n    const timestamp = formatTimestamp(entry.offset / 1000);n    const text = entry.text.trim();n    n    if (text) {n      lines.push(`**[${timestamp}]** ${text}\n`);n    }n  });nn  return lines.join('');n};nnexport const createJsonTranscript = (transcript: TranscriptEntry[]): string => {n  return JSON.stringify(transcript, null, 2);n};nnexport const createTsvTranscript = (transcript: TranscriptEntry[]): string => {n  const lines = ['Timestamp\tText\n'];nn  transcript.forEach(entry => {n    const timestamp = formatTimestamp(entry.offset / 1000);n    const text = entry.text.trim().replace(/\t/g, ' ');n    n    if (text) {n      lines.push(`${timestamp}\t${text}\n`);n    }n  });nn  return lines.join('');n};nnexport const cleanTranscriptText = (text: string): string => {n  // Remove extra whitespace and normalizen  let cleaned = text.replace(/\s+/g, ' ').trim();n  n  // Remove common transcript artifactsn  cleaned = cleaned.replace(/\[.*?\]/g, ''); // Remove bracketed contentn  cleaned = cleaned.replace(/\(.*?\)/g, ''); // Remove parenthetical contentn  n  return cleaned;n};