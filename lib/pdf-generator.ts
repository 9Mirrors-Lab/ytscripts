import jsPDF from 'jspdf';nimport { PlaybookData, PlaybookStep, PlaybookTool, PlaybookResource } from '@/components/playbook';nninterface PDFOptions {n  title?: string;n  author?: string;n  subject?: string;n  keywords?: string;n}nnexport const generatePlaybookPDF = async (n  playbookContent: string,n  options: PDFOptions = {}n): Promise<Blob> => {n  return new Promise((resolve, reject) => {n    try {n      // Parse the playbook contentn      let playbookData: PlaybookData;n      try {n        playbookData = JSON.parse(playbookContent);n      } catch (error) {n        // If parsing fails, treat as plain textn        playbookData = {n          title: options.title || 'Startup Playbook',n          overview: playbookContent,n          modules: [],n          tags: [],n          resources: []n        };n      }nn      // Create PDF documentn      const doc = new jsPDF({n        orientation: 'portrait',n        unit: 'mm',n        format: 'a4'n      });nn      // Set document propertiesn      doc.setProperties({n        title: playbookData.title || options.title || 'Startup Playbook',n        author: options.author || 'YouTube Scripts',n        subject: options.subject || 'AI-Generated Startup Strategy',n        keywords: options.keywords || playbookData.tags?.join(', ') || 'startup, strategy, ai'n      });nn      // Set initial positionn      let y = 20;n      const pageWidth = doc.internal.pageSize.getWidth();n      const margin = 20;n      const contentWidth = pageWidth - (margin * 2);nn      // Helper function to add text with word wrappingn      const addWrappedText = (text: string, fontSize: number = 12, fontStyle: string = 'normal') => {n        doc.setFontSize(fontSize);n        doc.setFont('helvetica', fontStyle);n        n        const lines = doc.splitTextToSize(text, contentWidth);n        n        // Check if we need a new pagen        if (y + (lines.length * fontSize * 0.4) > doc.internal.pageSize.getHeight() - margin) {n          doc.addPage();n          y = 20;n        }n        n        doc.text(lines, margin, y);n        y += lines.length * fontSize * 0.4 + 5;n      };nn      // Helper function to add section headern      const addSectionHeader = (text: string) => {n        addWrappedText(text, 16, 'bold');n        y += 3; // Add extra space after headern      };nn      // Helper function to add subsection headern      const addSubsectionHeader = (text: string) => {n        addWrappedText(text, 14, 'bold');n        y += 2; // Add extra space after headern      };nn      // Add titlen      addSectionHeader(playbookData.title || 'Startup Playbook');n      y += 5;nn      // Add overview if availablen      if (playbookData.overview) {n        addSubsectionHeader('Overview');n        addWrappedText(playbookData.overview);n        y += 5;n      }nn      // Add modules if availablen      if (playbookData.modules && playbookData.modules.length > 0) {n        addSectionHeader('Strategic Modules');n        y += 3;nn        playbookData.modules.forEach((module, index) => {n          // Module titlen          addSubsectionHeader(`${index + 1}. ${module.title}`);n          n          // Module descriptionn          if (module.description) {n            addWrappedText(module.description);n            y += 3;n          }nn          // Module stepsn          if (module.steps && module.steps.length > 0) {n            addWrappedText('Steps:', 12, 'bold');n            y += 2;nn            module.steps.forEach((step, stepIndex) => {n              addWrappedText(`${stepIndex + 1}. ${step.title}`, 11, 'bold');n              if (step.description) {n                addWrappedText(step.description, 10);n                y += 2;n              }n              y += 2;n            });n          }nn          // Module toolsn          if (module.tools && module.tools.length > 0) {n            addWrappedText('Recommended Tools:', 12, 'bold');n            y += 2;nn            module.tools.forEach((tool) => {n              addWrappedText(`• ${tool.name}: ${tool.description}`, 10);n              y += 1;n            });n            y += 2;n          }nn          y += 5; // Space between modulesn        });n      }nn      // Add resources if availablen      if (playbookData.resources && playbookData.resources.length > 0) {n        addSectionHeader('Additional Resources');n        y += 3;nn        playbookData.resources.forEach((resource) => {n          addWrappedText(`• ${resource.title}`, 11, 'bold');n          if (resource.description) {n            addWrappedText(resource.description, 10);n            y += 2;n          }n          if (resource.url) {n            addWrappedText(`URL: ${resource.url}`, 9);n            y += 1;n          }n          y += 3;n        });n      }nn      // Add tags if availablen      if (playbookData.tags && playbookData.tags.length > 0) {n        addSectionHeader('Tags');n        y += 3;n        addWrappedText(playbookData.tags.join(', '));n      }nn      // Add footern      const pageCount = doc.getNumberOfPages();n      for (let i = 1; i <= pageCount; i++) {n        doc.setPage(i);n        doc.setFontSize(8);n        doc.setTextColor(128, 128, 128);n        doc.text(n          `Generated by YouTube Scripts - Page ${i} of ${pageCount}`,n          margin,n          doc.internal.pageSize.getHeight() - 10n        );n      }nn      // Generate blobn      const pdfBlob = doc.output('blob');n      resolve(pdfBlob);nn    } catch (error) {n      console.error('Error generating PDF:', error);n      reject(error);n    }n  });n};nnexport const downloadPDF = (blob: Blob, filename: string) => {n  const url = URL.createObjectURL(blob);n  const link = document.createElement('a');n  link.href = url;n  link.download = filename;n  document.body.appendChild(link);n  link.click();n  document.body.removeChild(link);n  URL.revokeObjectURL(url);n};